import PDFDocument from "pdfkit";
import { Decimal } from "@prisma/client/runtime/library";

// Tangabiz brand colors
const COLORS = {
  primary: "#22c55e", // Green
  secondary: "#eab308", // Yellow
  dark: "#1f2937",
  gray: "#6b7280",
  lightGray: "#f3f4f6",
  white: "#ffffff",
};

export interface ReportData {
  title: string;
  businessName: string;
  businessLogo?: string;
  period: {
    start: Date;
    end: Date;
  };
  generatedAt: Date;
  generatedBy: string;
}

export interface SalesReportData extends ReportData {
  summary: {
    totalSales: number;
    totalTransactions: number;
    averageTransaction: number;
    topProducts: Array<{ name: string; quantity: number; revenue: number }>;
  };
  transactions: Array<{
    reference: string;
    date: Date;
    customer: string | null;
    items: number;
    total: number;
    paymentMethod: string;
  }>;
}

export interface InventoryReportData extends ReportData {
  summary: {
    totalProducts: number;
    totalValue: number;
    lowStockCount: number;
    outOfStockCount: number;
  };
  products: Array<{
    name: string;
    sku: string | null;
    category: string | null;
    quantity: number;
    price: number;
    value: number;
  }>;
}

export interface CustomerReportData extends ReportData {
  summary: {
    totalCustomers: number;
    newCustomers: number;
    activeCustomers: number;
  };
  customers: Array<{
    name: string;
    email: string | null;
    phone: string | null;
    totalTransactions: number;
    totalSpent: number;
    lastTransaction: Date | null;
  }>;
}

/**
 * Format currency
 */
function formatCurrency(amount: number, currency = "USD"): string {
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency,
  }).format(amount);
}

/**
 * Format date
 */
function formatDate(date: Date): string {
  return new Intl.DateTimeFormat("en-US", {
    year: "numeric",
    month: "long",
    day: "numeric",
  }).format(date);
}

/**
 * Add header to PDF document
 */
function addHeader(doc: PDFKit.PDFDocument, data: ReportData): void {
  // Header background
  doc.rect(0, 0, doc.page.width, 80).fill(COLORS.primary);

  // Business name
  doc.fontSize(24).fillColor(COLORS.white).text(data.businessName, 50, 25, {
    width: doc.page.width - 100,
  });

  // Report title
  doc.fontSize(12).fillColor(COLORS.white).text(data.title, 50, 55);

  // Period info on the right
  doc
    .fontSize(10)
    .fillColor(COLORS.white)
    .text(
      `${formatDate(data.period.start)} - ${formatDate(data.period.end)}`,
      doc.page.width - 200,
      30,
      { width: 150, align: "right" }
    );

  // Generated info
  doc
    .fontSize(8)
    .text(`Generated: ${formatDate(data.generatedAt)}`, doc.page.width - 200, 50, {
      width: 150,
      align: "right",
    });

  doc.moveDown(4);
}

/**
 * Add footer to PDF document
 */
function addFooter(doc: PDFKit.PDFDocument, pageNumber: number): void {
  const bottom = doc.page.height - 40;

  doc
    .fontSize(8)
    .fillColor(COLORS.gray)
    .text(`Page ${pageNumber}`, 50, bottom, { align: "left" })
    .text("Generated by Tangabiz - Business Management Platform", 0, bottom, {
      align: "center",
      width: doc.page.width,
    });
}

/**
 * Add summary section
 */
function addSummarySection(
  doc: PDFKit.PDFDocument,
  title: string,
  items: Array<{ label: string; value: string }>
): void {
  doc.fontSize(14).fillColor(COLORS.dark).text(title, { underline: true });
  doc.moveDown(0.5);

  const startY = doc.y;
  const boxWidth = (doc.page.width - 100) / items.length;

  items.forEach((item, index) => {
    const x = 50 + index * boxWidth;

    // Box background
    doc.rect(x, startY, boxWidth - 10, 50).fill(COLORS.lightGray);

    // Label
    doc.fontSize(10).fillColor(COLORS.gray).text(item.label, x + 10, startY + 10, {
      width: boxWidth - 30,
    });

    // Value
    doc
      .fontSize(16)
      .fillColor(COLORS.primary)
      .text(item.value, x + 10, startY + 28, {
        width: boxWidth - 30,
      });
  });

  doc.y = startY + 60;
  doc.moveDown();
}

/**
 * Add table to PDF document
 */
function addTable(
  doc: PDFKit.PDFDocument,
  headers: string[],
  rows: string[][],
  columnWidths: number[]
): void {
  const tableTop = doc.y;
  const tableLeft = 50;
  const rowHeight = 25;
  const pageHeight = doc.page.height - 80;

  // Header row
  let y = tableTop;
  doc.rect(tableLeft, y, doc.page.width - 100, rowHeight).fill(COLORS.primary);

  let x = tableLeft;
  headers.forEach((header, i) => {
    doc.fontSize(10).fillColor(COLORS.white).text(header, x + 5, y + 8, {
      width: columnWidths[i] - 10,
    });
    x += columnWidths[i];
  });

  y += rowHeight;

  // Data rows
  rows.forEach((row, rowIndex) => {
    // Check if we need a new page
    if (y + rowHeight > pageHeight) {
      doc.addPage();
      y = 50;
    }

    // Alternating row colors
    const bgColor = rowIndex % 2 === 0 ? COLORS.white : COLORS.lightGray;
    doc.rect(tableLeft, y, doc.page.width - 100, rowHeight).fill(bgColor);

    x = tableLeft;
    row.forEach((cell, i) => {
      doc.fontSize(9).fillColor(COLORS.dark).text(cell, x + 5, y + 8, {
        width: columnWidths[i] - 10,
      });
      x += columnWidths[i];
    });

    y += rowHeight;
  });

  doc.y = y + 10;
}

/**
 * Generate a sales report PDF
 */
export async function generateSalesReport(data: SalesReportData): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const chunks: Buffer[] = [];
    const doc = new PDFDocument({ size: "A4", margin: 50 });

    doc.on("data", (chunk) => chunks.push(chunk));
    doc.on("end", () => resolve(Buffer.concat(chunks)));
    doc.on("error", reject);

    // Add header
    addHeader(doc, data);

    // Summary section
    addSummarySection(doc, "Sales Summary", [
      { label: "Total Sales", value: formatCurrency(data.summary.totalSales) },
      { label: "Transactions", value: data.summary.totalTransactions.toString() },
      { label: "Avg. Transaction", value: formatCurrency(data.summary.averageTransaction) },
    ]);

    // Top products section
    if (data.summary.topProducts.length > 0) {
      doc.fontSize(14).fillColor(COLORS.dark).text("Top Products", { underline: true });
      doc.moveDown(0.5);

      const topProductRows = data.summary.topProducts.map((p) => [
        p.name,
        p.quantity.toString(),
        formatCurrency(p.revenue),
      ]);

      addTable(doc, ["Product", "Qty Sold", "Revenue"], topProductRows, [250, 100, 100]);
    }

    // Transactions table
    doc.moveDown();
    doc.fontSize(14).fillColor(COLORS.dark).text("Transactions", { underline: true });
    doc.moveDown(0.5);

    const transactionRows = data.transactions.map((t) => [
      t.reference,
      formatDate(t.date),
      t.customer || "Walk-in",
      t.items.toString(),
      formatCurrency(t.total),
      t.paymentMethod,
    ]);

    addTable(
      doc,
      ["Reference", "Date", "Customer", "Items", "Total", "Payment"],
      transactionRows,
      [80, 90, 100, 50, 80, 80]
    );

    // Add footer
    addFooter(doc, 1);

    doc.end();
  });
}

/**
 * Generate an inventory report PDF
 */
export async function generateInventoryReport(data: InventoryReportData): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const chunks: Buffer[] = [];
    const doc = new PDFDocument({ size: "A4", margin: 50 });

    doc.on("data", (chunk) => chunks.push(chunk));
    doc.on("end", () => resolve(Buffer.concat(chunks)));
    doc.on("error", reject);

    // Add header
    addHeader(doc, data);

    // Summary section
    addSummarySection(doc, "Inventory Summary", [
      { label: "Total Products", value: data.summary.totalProducts.toString() },
      { label: "Total Value", value: formatCurrency(data.summary.totalValue) },
      { label: "Low Stock", value: data.summary.lowStockCount.toString() },
      { label: "Out of Stock", value: data.summary.outOfStockCount.toString() },
    ]);

    // Products table
    doc.moveDown();
    doc.fontSize(14).fillColor(COLORS.dark).text("Products", { underline: true });
    doc.moveDown(0.5);

    const productRows = data.products.map((p) => [
      p.name,
      p.sku || "-",
      p.category || "-",
      p.quantity.toString(),
      formatCurrency(p.price),
      formatCurrency(p.value),
    ]);

    addTable(
      doc,
      ["Product", "SKU", "Category", "Qty", "Price", "Value"],
      productRows,
      [150, 70, 80, 50, 70, 70]
    );

    // Add footer
    addFooter(doc, 1);

    doc.end();
  });
}

/**
 * Generate a customer report PDF
 */
export async function generateCustomerReport(data: CustomerReportData): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const chunks: Buffer[] = [];
    const doc = new PDFDocument({ size: "A4", margin: 50 });

    doc.on("data", (chunk) => chunks.push(chunk));
    doc.on("end", () => resolve(Buffer.concat(chunks)));
    doc.on("error", reject);

    // Add header
    addHeader(doc, data);

    // Summary section
    addSummarySection(doc, "Customer Summary", [
      { label: "Total Customers", value: data.summary.totalCustomers.toString() },
      { label: "New Customers", value: data.summary.newCustomers.toString() },
      { label: "Active Customers", value: data.summary.activeCustomers.toString() },
    ]);

    // Customers table
    doc.moveDown();
    doc.fontSize(14).fillColor(COLORS.dark).text("Customer Details", { underline: true });
    doc.moveDown(0.5);

    const customerRows = data.customers.map((c) => [
      c.name,
      c.email || "-",
      c.phone || "-",
      c.totalTransactions.toString(),
      formatCurrency(c.totalSpent),
    ]);

    addTable(
      doc,
      ["Name", "Email", "Phone", "Transactions", "Total Spent"],
      customerRows,
      [120, 130, 90, 80, 80]
    );

    // Add footer
    addFooter(doc, 1);

    doc.end();
  });
}
